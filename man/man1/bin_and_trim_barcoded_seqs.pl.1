.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BIN_AND_TRIM_BARCODED_SEQS 1"
.TH BIN_AND_TRIM_BARCODED_SEQS 1 "2010-10-22" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
bin_and_trim_barcoded_seqs.pl \- Take a set of barcoded sequences, group them by barcode and trim primers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
bin_and_trim_barcoded_seqs.pl 
         \-\-input_file=/path/to/input_seqs.fasta
         \-\-reverse_primer='\s-1CATGCTGCCTCCCGTAGGAGT\s0'
         \-\-forward_primer='\s-1CTGAGCCAGGATCAAACTCT\s0'
         \-\-barcode_file=/path/to/barcodes.txt
        [\-\-output_dir=/path/to/output_dir
         \-\-min_length=200
         \-\-max_edit_dist=2
         \-\-max_barcode_offset=4
         \-\-trim=all
         \-\-log=/path/to/some.log
         \-\-debug=4
         \-\-help ]
.SH "OPTIONS"
.IX Header "OPTIONS"
\&\fB\-\-input_file, \-i\fR
    a multi-FASTA file containing the barcoded sequences to bin and trim.  currently the 
    input sequences \s-1MUST\s0 be in all\-uppercase.
.PP
\&\fB\-\-reverse_primer, \-r\fR
    the reverse primer sequence to search for at the beginning of each sequence (following
    the barcode).  if a linker sequence appears between the sequence barcode and the reverse
    primer it should be included in the \-\-reverse_primer sequence.  the script assumes that
    the first two bases of \-\-reverse_primer are a dinucleotide linker sequences, but the 
    only place where this information is used is in a special-case check to see how many 
    sequences contain the barcode and the reverse primer, but \s-1NOT\s0 the first two characters
    of the reverse primer (the presumed linker sequence)
.PP
\&\fB\-\-forward_primer, \-f\fR
    the (reverse complement of) the forward primer sequence to search for at the end of each 
    sequence.
.PP
\&\fB\-\-barcode_file,\-b\fR
    a whitespace-delimited text file that specifies the barcodes used to identify sequences in
    \-\-input_file.  each line of the file has two columns: the first specifies the (unique)
    \s-1DNA\s0 sequence barcode and the second specifies the corresponding well number or sample \s-1ID\s0, 
    as needed.  for example:
.PP
.Vb 4
\&    ACACACTG    A01
\&    ACACGTCA    A02
\&    ACAGACAG    A03
\&    ACAGCTCA    A04
.Ve
.PP
\&\fB\-\-output_dir, \-o\fR
	optional.  directory where the output files will be stored.  this directory will be created
    if it does not exist.  if this option is not specified then the directory that contains 
    \-\-input_file will be used for the output. 
.PP
\&\fB\-\-min_length, \-m\fR
    optional.  minimum sequence length required after trimming.  (default is 200 bp)
.PP
\&\fB\-\-max_edit_dist, \-D\fR
    maximum edit distance between reverse primer and sequence. (default is 2)
.PP
\&\fB\-\-max_barcode_offset, \-B\fR
    maximum sequence position at which to look for the (start of) the barcode sequence. (default is 4)
    for example, to ensure that the barcode always starts at the very beginning of each sequence, set
    \-\-max_barcode_offset=0
.PP
\&\fB\-\-trim, \-t\fR
    optional. specifies what to trim off the sequences:
      'all' (the default) \- trim both the barcode and the primer(s)
      'barcodes' \- trim only the barcode but leave the primer(s) intact
      'none' \- bin the sequences based on barcode but do not do any barcode or primer trimming
    Note that the forward primer may not always be present (e.g., when the read length of the 
    underlying sequencing technology is significantly shorter than the expected insert size.)
.PP
\&\fB\-\-log,\-l\fR
    optional.  path to a log file the script should create.  will be overwritten if
    it already exists.
.PP
\&\fB\-\-debug,\-d\fR
    optional.  the debug level for the logger (an integer)
.PP
\&\fB\-\-help,\-h\fR
    This help message/documentation.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Take a set of barcoded sequences, group them by barcode and trim primers.  The script
takes as input a single multi-FASTA file of sequences and divides them amongst a set of
output files based on the persence of an embedded sequence barcode (e.g., \*(L"\s-1ACACACTG\s0\*(R").
The script will trim the barcode sequence off each sequence, in addition to trimming 
the reverse and forward primers (\-\-reverse_primer and \-\-forward_primer), if they can
be found.  The \-\-trim option can be used to specify the trimming behavior: trim neither
the barcode nor the primers, trim only the barcode, or trim both the primers and the
barcode.
.PP
Each sequence with a recognizable barcode will be placed in an output file whose name
contains both the barcode and also the well/sample \s-1ID\s0 specified for that barcode in 
the \-\-barcode_file.  For example, if the input sequence file is \*(L"input.fsa\*(R", the barcode
detected in the sequence is \*(L"\s-1TGCATCGA\s0\*(R", and the sample id that corresponds to that 
barcode is \*(L"H12\*(R" then the (trimmed) sequence will be placed in one of the following 
two files:
.PP
input.fsa.H12.TGCATCGA.filtered
input.fsa.H12.TGCATCGA.discarded
.PP
A sequence will be placed in the \*(L".filtered\*(R" file if both the barcode and the reverse
primer can be found (within \-\-max_edit_dist), and the length of the sequence after 
trimming is greater than or equal to the minimum value specified by \-\-min_length.  
If the reverse primer cannot be found or the length of the sequence after trimming is
below the threshold then the (perhaps partially trimmed) sequence will be placed in 
the \*(L".discarded\*(R" file.  (If reverse primer trimming is disabled then the presence of
the reverse primer isn't required for the sequence to be placed in the \*(L".filtered\*(R"
file.)  Any sequence without a recognizable barcode will be placed in a discard
file named based solely on the input file, e.g.:
.PP
test.fsa.discarded
.PP
The \s-1FASTA\s0 header line of the sequences (in both the .filtered and .discarded files) 
will be updated to reflect the trimming and barcode/primer matching.  For example, 
in the following defline:
.PP
>000123_456_789 length=261 uaccno=XXFABC40343|E01|CTGAGTGT|trimmed_length:232|rev_primer_mismatches:0|fwd_primer_mismatches:NA
.PP
The new fields are:
.PP
E01: 
 well/sample id that corresponds to the barcode '\s-1CTGAGTGT\s0'
\&\s-1CTGAGTGT:\s0 
 literal barcode that was identified in the sequence (and trimmed, unless \-\-trim=none)
trimmed_length
 the length of the sequence after trimming the barcode and/or primers
rev_primer_mismatches: 
 edit distance between the canonical reverse primer given by \-\-reverse_primer and the 
 primer found in the sequence.  should always be <= \-\-max_edit_dist.  \*(L"\s-1NA\s0\*(R" means that
 the primer was not found.
fwd_primer_mismatches:
 edit distance between the canonical forward primer given by \-\-forward_primer and the 
 primer found in the sequence.  this value will always be either 0 (exact match) or 
 \*(L"\s-1NA\s0\*(R" (no match) since approximate matching of forward primers is not yet supported.
.SH "INPUT"
.IX Header "INPUT"
A multi-FASTA formatted file of sequences to bin and trim (specified by \-\-input_file) 
and a set of unique barcodes (specified by \-\-barcode_file).  Currently the input sequences,
barcodes, and primers must be all\-uppercase.
.SH "OUTPUT"
.IX Header "OUTPUT"
A set of multi-FASTA formatted files as described above.  The script also prints the 
following information to \s-1STDOUT:\s0
.PP
Levenshtein edit distance histogram for reverse \s-1RNA\s0 primer:
.PP
.Vb 4
\&    distance      num_seqs
\&           0        239058
\&           1          5014
\&           2*          289
.Ve
.PP
.Vb 2
\&       total        244361
\&* - setting for --max_edit_dist
.Ve
.PP
Indel count histogram for reverse \s-1RNA\s0 primer:
.PP
.Vb 6
\&      indels      num_seqs
\&          -2           155
\&          -1          1925
\&           0        241723
\&           1           503
\&           2            55
.Ve
.PP
.Vb 1
\&       total        244361
.Ve
.PP
Number of reverse primers that match exactly except for missing \s-1CA\s0 linker: 45
.SH "CONTACT"
.IX Header "CONTACT"
.Vb 2
\&    William Hsiao
\&    william.hsiao@gmail.com
.Ve
.Sh "\s-1TODO:\s0 \-Check additional barcodes beyond the first (in the case of multiple matches) if choosing the first one fails to match the primer sequence(s) \-Relax requirement that all the input sequences and primers have to be all\-uppercase. \-Allow approximate matches to the forward primer. \-Check the product size in cases where both primers are found?"
.IX Subsection "TODO: -Check additional barcodes beyond the first (in the case of multiple matches) if choosing the first one fails to match the primer sequence(s) -Relax requirement that all the input sequences and primers have to be all-uppercase. -Allow approximate matches to the forward primer. -Check the product size in cases where both primers are found?"
