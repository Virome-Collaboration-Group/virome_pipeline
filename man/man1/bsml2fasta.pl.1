.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BSML2FASTA 1"
.TH BSML2FASTA 1 "2010-10-22" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
bsml2fasta.pl \- convert BSML files to fasta
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\s-1USAGE:\s0  bsml2fasta.pl 
          \-\-bsml_input=/path/to/fileORdir | \-\-bsml_list=/path/to/file
          \-\-format=single|multi
        [ \-\-output_list=/path/to/somefile.list
          \-\-output_subdir_size=20000
          \-\-output_subdir_prefix='somename'
          \-\-parse_element=sequence|feature
          \-\-class_filter=someclass 
          \-\-bp_extension=#bpadjacentgenomicseq
          \-\-coords=0|1
          \-\-suffix=fsa
          \-\-debug=debug_level 
          \-\-log=log_file
          \-\-use_feature_ids_in_fasta=0|1
          \-\-use_sequence_ids_in_fasta=0|1
        ]
.SH "OPTIONS"
.IX Header "OPTIONS"
\&\fB\-\-bsml_input,\-i\fR 
    Input files or folders.  Can be a comma-separated list of mixed input types.
.PP
\&\fB\-\-bsml_list,\-s\fR 
    Text file that is a list of input files and/or folders.
.PP
\&\fB\-\-class_filter,\-c\fR 
    Optional. Filter output sequences to only include those in the passed class.
.PP
\&\fB\-\-role_exclude\fR 
    Optional. Filter output sequences to include those with a given role link (can be a comma separated list).
.PP
\&\fB\-\-role_include\fR 
    Optional. Filter output sequences to exclude those with a given role link (can be a comma separated list).
.PP
\&\fB\-\-debug,\-d\fR 
    Optional. Debug level.  Use a large number to turn on verbose debugging. 
.PP
\&\fB\-\-format,\-f\fR 
    Format.  'multi' (default) writes all sequences to a multi-fasta file, and 'single' writes each sequence in a separate file named like \f(CW$id\fR.fsa
.PP
\&\fB\-\-suffix\fR 
    suffix of the output files. Defaults to fsa
.PP
\&\fB\-\-log,\-l\fR 
    Log file
.PP
\&\fB\-\-use_feature_ids_in_fasta\fR
    Set this to nonzero to use the \s-1BSML\s0 id of the linked feature that corresponds to each sequence being written.  
    The script will fail if any of the exported sequences are linked to multiple features. Also nNote that this 
    option will only work if \-\-parse_element=sequence.
.PP
\&\fB\-\-use_sequence_ids_in_fasta\fR
    Set this to nonzero to use the \s-1BSML\s0 id of the sequence element (rather than the identifier for the 
    Seq\-data/Seq\-data\-importfor each sequence being written. Also Note that this option will only work 
    if \-\-parse_element=sequence.
.PP
\&\fB\-\-output,\-o\fR 
    Output file (if \-\-format=multi) or directory (if \-\-format=single)
.PP
\&\fB\-\-output_list,\-u\fR
    Optional.  If passed, will create a list file containing the path to each of the
    files created.
.PP
\&\fB\-\-output_subdir_size,\-z\fR
    Optional.  Number of files to create within each output subdirectory.
.PP
\&\fB\-\-output_subdir_prefix,\-x\fR
    Optional.  Rather than just plain numberical names (N), output subdirectories will
    be named like \*(L"prefixN\*(R" if you pass a prefix with this.
.PP
\&\fB\-\-bp_extension\fR
    Optional. Number of genomic bp to retrieve adjacent to feature
.PP
\&\fB\-\-coords\fR
    Optional. Output the coordinates in the header of the fasta.
.PP
\&\fB\-\-help,\-h\fR 
    This help message
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This script is used to convert \s-1BSML\s0 to fasta.  The input is meant to be as flexible 
as possible and is described below.  The output can be either a single file with 
multiple entries, or separate files for each entry.
.SH "INPUT"
.IX Header "INPUT"
Input can be either a single file, a directory of files, or a list.  A list is
a text file containing a list of either files or directories, one on each line.
.PP
Any individual .bsml file can have as many <Sequence> elements as it likes.  They
will all get exported as \s-1FASTA\s0 unless you use the \-\-class_filter option to include
only certain classes.
.PP
The \-\-bsml_input option is used to pass files or directories.  The following
example passes a single bsml file:
.PP
.Vb 1
\&    bsml2fasta.pl --bsml_input=/foo/bar/dnaA.bsml
.Ve
.PP
We can pass multiple files in a comma-separated list (use quotes):
.PP
.Vb 1
\&    bsml2fasta.pl --bsml_input="/foo/bar/dnaA.bsml, /foo/bar/tonB.bsml"
.Ve
.PP
If /foo/bar had many .bsml files in it and we want to process them all, we could 
just do:
.PP
.Vb 1
\&    bsml2fasta.pl --bsml_input=/foo/bar
.Ve
.PP
Also multiple directories are ok:
.PP
.Vb 1
\&    bsml2fasta.pl --bsml_input="/foo/bar, /home/you"
.Ve
.PP
You can even mix directories and files:
.PP
.Vb 1
\&    bsml2fasta.pl --bsml_input="/foo/bar/dnaA.bsml, /home/you"
.Ve
.PP
Lists are useful if you have a specific set of files or directories to process.
If we have a file named, for example, '/foo/bar/neatstuff.list', which has contents 
like (the .list suffix is completely optional):
.PP
.Vb 4
\&    /foo/bar/thingy1.bsml
\&    /foo/bar/thingy2.bsml
\&    ...
\&    /foo/bar/thingy1034.bsml
.Ve
.PP
You can pass this list to the script:
.PP
.Vb 1
\&    bsml2fasta.pl --bsml_list=/foo/bar/neatstuff.list
.Ve
.PP
If one of the lines in the list is a path to a directory rather than a file, each
\&.bsml file in that directory will be processed.  A list can contain paths to both
files and directories such as:
.PP
.Vb 5
\&    /foo/bar/thingy1.bsml
\&    /foo/bar/thingy2.bsml
\&    ...
\&    /foo/bar/thingy1034.bsml
\&    /home/you
.Ve
.PP
Finally, you can be really messy and mix input types and methods to process files,
directories and lists all at the same time:
.PP
.Vb 1
\&    bsml2fasta.pl --bsml_input="/foo/bar/dnaA.bsml, /home/you" --bsml_list=/home/you/some.list
.Ve
.PP
Once everything is evaluated down to the file\-level, all will be skipped that
don't have a .bsml suffix.
.SH "OUTPUT"
.IX Header "OUTPUT"
Output is specified using the required \-\-output and optional \-\-format options.  By
default the output will be a single file containing multiple \s-1FASTA\s0 entries.  So:
.PP
.Vb 1
\&    bsml2fasta.pl --bsml_input=/foo/bar --output=/home/you/seqs.fsa
.Ve
.PP
This would read all the .bsml files in /foo/bar and write their sequences to the
seqs.fsa file in /home/you in multi-FASTA format.  If you want each sequence to be
output separately, you need to use the \-\-format=single option:
.PP
.Vb 1
\&    bsml2fasta.pl --bsml_input=/foo/bar --output=/home/you/data --format=single
.Ve
.PP
This would write each sequence to its own .fsa file into the /home/you/data directory.
Each file will be named using the id attribute of each sequence, like \f(CW$id\fR.fsa .
\&\-\-format=multi is the default and does not need to be passed explicitly.  Note that
the only legal characters for the file name are in the set [ a\-z A\-Z 0\-9 \- _ . ].  Any
other characters will be replaced with underscores.  These replacements will only occur
in the file name;  the header will still have the original id.  The complete fasta header
for each entry will be composed of the id followed by a single space, and then the
\&'title' attribute of the sequence, if one exists.  For example:
.PP
.Vb 1
\&    >gi28804993 chromosomal DNA replication initiator DnaA [Vibrio parahaemolyticus]
.Ve
.PP
If you are reading in multiple sequences and want to filter which are included in
the output, you can do this based on their class attributes by passing the
\&\-\-class_filter option:
.PP
.Vb 1
\&    bsml2fasta.pl --bsml_input=/foo/bar --output=/home/you/seqs.fsa --class_filter=cds
.Ve
.PP
This will filter the sequences in /foo/bar to only include those that are of the
cds class.  Sequences without class attributes will not be included if \-\-class_filter
is used.  The values of these class attributes can be anything, but should correspond 
to \s-1SO\s0 terms.
.PP
You can pass a path to the optional \-\-output_list to create a text file containing the full paths
to each of the \s-1FASTA\s0 files created by this script.
.PP
Two other optional arguments, \-\-output_subdir_size and \-\-output_subdir_prefix, can be used
on input sets that are too large to write out to one directory.  This depends on the limitations
of your file system, but you usually don't want 100,000 files written in the same directory.
.PP
If you are going to create 95000 sequences, and use the following option:
.PP
.Vb 2
\&    --output=/some/path
\&    --output_subdir_size=30000
.Ve
.PP
The following will be created:
.PP
.Vb 6
\&    directory              file count
\&    ---------------------------------
\&    /some/path/1/          30000
\&    /some/path/2/          30000
\&    /some/path/3/          30000
\&    /some/path/4/           5000
.Ve
.PP
If you choose to create a list file (and you probably want to), it will contain these proper paths.
.PP
You may not want the subdirectories to simply be numbers, as above, so you can use the
\&\-\-output_subdir_prefix option.  For example:        
.PP
.Vb 3
\&    --output=/some/path
\&    --output_subdir_size=30000
\&    --output_subdir_prefix=fasta
.Ve
.PP
The following will be created:
.PP
.Vb 6
\&    directory              file count
\&    ---------------------------------
\&    /some/path/fasta1/     30000
\&    /some/path/fasta2/     30000
\&    /some/path/fasta3/     30000
\&    /some/path/fasta4/      5000
.Ve
.SH "CONTACT"
.IX Header "CONTACT"
.Vb 2
\&    Sam Angiuoli
\&    angiuoli@users.sf.net
.Ve
.PP
.Vb 2
\&    Joshua Orvis
\&    jorvis@users.sf.net
.Ve
