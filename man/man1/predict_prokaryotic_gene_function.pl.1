.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PREDICT_PROKARYOTIC_GENE_FUNCTION 1"
.TH PREDICT_PROKARYOTIC_GENE_FUNCTION 1 "2010-10-22" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
predict_gene_function.pl \- Reads annotation evidence for a gene and generates a functional
prediction with product name, gene symbol, EC number and GO terms where possible.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\s-1USAGE:\s0 predict_gene_function.pl 
            \-\-input_list=/path/to/bsml.list
            \-\-output_directory=/some/dir
          [ \-\-hmm_list=/path/to/hmm_bsml.list
            \-\-hmm_info=/path/to/hmminfo.db
            \-\-ber_list=/path/to/ber_bsml.list
            \-\-ber_info=/path/to/berinfo.db
            \-\-annotate_on=transcript ]
.SH "OPTIONS"
.IX Header "OPTIONS"
\&\fB\-\-input_list\fR
    \s-1BSML\s0 input list, usually the output of the auto_gene_curation Ergatis component.
.PP
\&\fB\-\-output_directory\fR
    This is where the output \s-1BSML\s0 containing functional predictions will be written.
.PP
\&\fB\-\-hmm_list\fR
    Optional. Ouput list of \s-1HMM\s0 evidence in \s-1BSML\s0 format.
.PP
\&\fB\-\-hmm_info\fR
    Optional (unless \-\-hmm_list defined) \s-1MLDBM\s0 file (tied hash) on disk that stores 
    attributes of \s-1HMM\s0 entries in your search database.  See the hmmlib_to_mldbm.pl 
    script for more info.
.PP
\&\fB\-\-ber_list\fR
    Optional. Output list of \s-1BER\s0 evidence in \s-1BSML\s0 format.
.PP
\&\fB\-\-ber_info\fR
    Optional (unless \-\-ber_list is defined).  \s-1MLDBM\s0 file (tied hash) on disk that stores 
    attributes of matched \s-1BER\s0 accessions from your search.  See the tchar_to_mldbm.pl
    script for more info.
.PP
\&\fB\-\-annotate_on\fR
    Optional. On which feature type should annotation be assigned?  (default = transcript)
.PP
\&\fB\-\-log,\-l\fR 
    Log file of all steps in the prediction process.  You should probably use this.
.PP
\&\fB\-\-help,\-h\fR
    This help message
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A relatively simple approach to functional prediction, this script considers evidence in
the following order:
.PP
.Vb 11
\&   1. Equivalog HMM above trusted cutoff
\&   2. Characterized BER match (later, with at least 35% identity (configurable) and over 80% of the query length (configurable))
\&   3. Full-length subfamily HMM (will append 'family protein')
\&   4. Equivalog-domain HMM
\&   5. Superfamily HMM (will append 'family protein')
\&   6. Subfamily domain (will append 'domain protein')
\&   7. Domain HMM (will append 'domain protein')
\&   8. PFAM isology (will append 'family protein')
\&   9. consider tmhmm - if 50% (configurable) of protein is involved in tmhmm matches gene product will be 'putative membrane protein'
\&  10. consider lipoprotein - If matches, gene product will be 'putative lipoprotein'
\&  11. Hypothetical equivalog HMM (will name 'conserved hypothetical protein')
.Ve
.SH "INPUT"
.IX Header "INPUT"
Throughout each of these \s-1BSML\s0 description sections I've removed elements from the examples
that aren't required for this script.  Other elements are optional and should be ignored
.Sh "Input \s-1BSML\s0 format"
.IX Subsection "Input BSML format"
The input \s-1BSML\s0 is first scanned so that relationships between features can be defined.  Most
of the computes are run on polypeptides, so if we're attaching annotations to \s-1CDS\s0 we need
to be able to define which polypeptide corresponds to which \s-1CDS\s0.  The section of the \s-1BSML\s0
that defines these relationships looks like this:
.PP
.Vb 7
\&    <Feature-group group-set="ctha1.gene.16128.1" id="Bsml958">
\&        <Feature-group-member featref="ctha1.gene.18117.1" feature-type="gene"></Feature-group-member>
\&        <Feature-group-member featref="ctha1.polypeptide.17997.1" feature-type="polypeptide"></Feature-group-member>
\&        <Feature-group-member featref="ctha1.CDS.18117.1" feature-type="CDS"></Feature-group-member>
\&        <Feature-group-member featref="ctha1.transcript.17997.1" feature-type="transcript"></Feature-group-member>
\&        <Feature-group-member featref="ctha1.exon.18117.1" feature-type="exon"></Feature-group-member>
\&    </Feature-group>
.Ve
.PP
Once these and the evidence are processed, annotation is added to the <Feature> elements.  (See \s-1OUTPUT\s0 section)
.Sh "\s-1HMM\s0 \s-1BSML\s0 format"
.IX Subsection "HMM BSML format"
The only section of the \s-1HMM\s0 \s-1BSML\s0 input considered are the alignments.  Each looks like this:
.PP
.Vb 11
\&    <Seq-pair-alignment refseq="ctha1.polypeptide.20147.1" refstart="0" compseq="TIGR00633" class="match">
\&        <Attribute name="total_e_value" content="4.3e-53"></Attribute>
\&        <Attribute name="total_score" content="187.6"></Attribute>
\&        <Seq-pair-run compcomplement="0" runlength="238" refpos="0" comprunlength="279" refcomplement="0" runscore="187.6" comppos="0">
\&            <Attribute name="class" content="match_part"></Attribute>
\&            <Attribute name="domain_num" content="1"></Attribute>
\&            <Attribute name="domain_of" content="1"></Attribute>
\&            <Attribute name="e_value" content="4.3e-53"></Attribute>
\&        </Seq-pair-run>
\&        <Link rel="analysis" href="#hmmpfam_analysis" role="computed_by"></Link>
\&    </Seq-pair-alignment>
.Ve
.Sh "\s-1BER\s0 \s-1BSML\s0 format"
.IX Subsection "BER BSML format"
Not yet written
.SH "OUTPUT"
.IX Header "OUTPUT"
The output of the script is a copy of the input \s-1BSML\s0 but with additional function definitions
added.  What was this, unannotated:
.PP
.Vb 3
\&    <Feature class="transcript" title="ctha1.transcript.1397901.1" id="ctha1.transcript.1397901.1">
\&      <Interval-loc complement="0" endpos="1378390" startpos="1378195"></Interval-loc>
\&    </Feature>
.Ve
.PP
Will become something like this, depending on how much evidence is present:
.PP
.Vb 24
\&    <Feature class="transcript" title="ctha1.transcript.1397901.1" id="ctha1.transcript.1397901.1">
\&      <Interval-loc complement="0" endpos="1378390" startpos="1378195"></Interval-loc>
\&      <Attribute name="gene_product_name" content="polyphosphate kinase"></Attribute>
\&      <Attribute name="gene_product_name_source" content="PF02503"></Attribute>
\&      <Attribute name="gene_symbol" content="ppk"></Attribute>
\&      <Attribute name="gene_symbol_source" content="PF02503"></Attribute>
\&      <Link rel="analysis" href="#predict_prokaryotic_gene_function_analysis" role="computed_by"></Link>
\&      <Attribute-list>
\&        <Attribute name="GO" content="GO:0006799"></Attribute>
\&        <Attribute name="IEA" content="PF02503"></Attribute>
\&      </Attribute-list>
\&      <Attribute-list>
\&        <Attribute name="GO" content="GO:0008976"></Attribute>
\&        <Attribute name="IEA" content="PF02503"></Attribute>
\&      </Attribute-list>
\&      <Attribute-list>
\&        <Attribute name="GO" content="GO:0009358"></Attribute>
\&        <Attribute name="IEA" content="PF02503"></Attribute>
\&      </Attribute-list>
\&      <Attribute-list>
\&        <Attribute name="EC" content="2.7.4.1"></Attribute>
\&        <Attribute name="IEA" content="PF02503"></Attribute>
\&      </Attribute-list>
\&    </Feature>
.Ve
.PP
The log file, if generated with the \-\-log option, contains a great deal of information about the
decision process for functional curation of each gene.
.SH "TESTING"
.IX Header "TESTING"
This is my command for testing.  This should be removed eventually, but I'm putting it here
because it takes a while to build the command.  :)
.PP
perl \-I /usr/local/projects/ergatis/package\-devel/lib/perl5/site_perl/5.8.8/ predict_prokaryotic_gene_function.pl \-\-input_list=/usr/local/projects/aengine/output_repository/auto_gene_curation/537_overlap_analysis/auto_gene_curation.bsml.list.all \-\-output_directory=/tmp/annotate \-\-hmm_list=/usr/local/projects/aengine/output_repository/hmmpfam/537_pre_overlap_analysis/hmmpfam.bsml.list \-\-hmm_info=/usr/local/projects/db/coding_hmm/coding_hmm.lib.db \-\-ber_list=/usr/local/projects/aengine/output_repository/ber/537_pre_overlap_analysis/ber.bsml.list \-\-ber_info=/usr/local/projects/db/tchar/tchar.db \-\-log=/tmp/annotate/annotation.log
.SH "DEVEL NOTES"
.IX Header "DEVEL NOTES"
Do we have a problem when features are versioned up and we point at \s-1BLAST\s0 or \s-1HMM\s0 results from
the previous version?  This needs to be considered, but since a version change usually implies
a sequence change the old result files would be stale.
.SH "CONTACT"
.IX Header "CONTACT"
.Vb 2
\&    Joshua Orvis
\&    jorvis@users.sf.net
.Ve
