.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PREPARE_FOR_GENEWISE_BEST_LOC 1"
.TH PREPARE_FOR_GENEWISE_BEST_LOC 1 "2010-10-22" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
prepare_for_geneWise.dbi
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\s-1USAGE:\s0 prepare_for_geneWise.dbi
           \-\-project|\-p                   aa1 
           \-\-bsml_list|\-i                 aat_aa.bsml.list
           \-\-bsml_file|\-I                 aat_aa_bsml_file
           \-\-work_dir|\-w                  working_directory
        [  \-\-verbose|\-v
           \-\-PADDING_LENGTH               500
           \-\-MIN_CHAIN_SCORE              50
           \-\-MIN_PERCENT_CHAIN_ALIGN      70
           \-\-num_tiers|n                  2
           \-\-JUST_PRINT_BEST_LOCATIONS
         ]
.SH "OPTIONS"
.IX Header "OPTIONS"
\&\fB\-\-project,\-p\fR
    Name of the project database 
.PP
\&\fB\-\-bsml_list,\-i\fR
    \s-1BSML\s0 list file as output by an aat_aa run
.PP
\&\fB\-\-bsml_file,\-I\fR
    \s-1BSML\s0 file, a sinlge output of an aat_aa run
.PP
\&\fB\-\-work_dir,\-w\fR
    Working directory to post the genome sequence segments and proteins to
    be aligned using genewise
.PP
\&\fB\-\-verbose,\-v\fR
    Verbose mode 
.PP
\&\fB\-\-PADDING_LENGTH\fR
    number of basepairs to extend the genome location on each end (default: 500)
.PP
\&\fB\-\-MIN_CHAIN_SCORE\fR
    minimum score for an alignment chain to be considered a candidate for genewise realignment.
    chain_score = sum (per_id * segment_length)
    default minimum score = 50
.PP
\&\fB\-\-MIN_PERCENT_CHAIN_ALIGN\fR
    mimimum percent of the matching proteins length that aligns to the genome in a single alignment chain.
    default: 70%
.PP
\&\fB\-\-num_tiers,\-n\fR
    number of overlapping best location hits.
    default: 2 (only the two best hits per location is extracted)
.PP
\&\fB\-\-JUST_PRINT_BEST_LOCATIONS\fR
    The best matches are reported to stdout.  No files are written.
.PP
\&\fB\-\-DUMP_CHAIN_STATS\fR
    All \s-1AAT\s0 alignments retrieved from the database are printed to a file \e$asmbl_id.chain_stats.
.PP
\&\fB\-\-help,\-h\fR
    This help documentation
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The best protein match to a given genomic region is extracted along with the genomic 
sequence corresponding to that region to be realigned using the genewise program.
.PP
The algorithm for finding the best match per location is as follows:  The results of an 
\&\s-1AAT\s0 search of a protein database against a genome assembly should be available for querying
from the evidence table.  All alignment chains are retrieved from the database and scored 
as the sum of (per_id * length) for each alignment segment.  The chains are sorted by score
and tiled to the genome, disallowing overlap among alignment chains along the genome.  Matches
to the top and bottom strands of the genome are tiled separately.  The first tier on each
strand contains the best hits per location.  Set \-\-num_tiers > 1 to extract multiple best hits per
location.
.PP
Each protein is retrieved from the protein database fasta file using the cdbyank utility.  Each 
genome region is extracted as a substring of the genome sequence.  Both the protein and genome
sequence substring are written as fasta files in the working directory, structured like so:
.PP
{\s-1WORKING_DIRECTORY\s0}/{asmbl_id}/{database}.assembly.{asmbl_id}.{counter}.pep
.PP
{\s-1WORKING_DIRECTORY\s0}/{asmbl_id}/{database}.assembly.{asmbl_id}.{counter}.fsa
.PP
for the protein and genome sequence region, respectively.  The counter is an integer incremented for
each genome location on each asmbl_id.
.PP
The header of the .fsa file is constructed like so:
.PP
{database}.assembly.{asmbl_id}.{end5}.{end3}
.PP
so that, by extracting the header for this entry, the exact genome coordinates can be inferred.
.PP
\&\s-1NOTE:\s0 this script is modified version of the old database-dependent prepare_for_genewise script.
.SH "CONTACT"
.IX Header "CONTACT"
.Vb 2
\&    Brett Whitty
\&    bwhitty@tigr.org
.Ve
