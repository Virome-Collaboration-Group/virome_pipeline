.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TWINSCAN2BSML 1"
.TH TWINSCAN2BSML 1 "2010-10-22" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
twinscan2bsml.pl \- convert twinscan GTF output to BSML
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\s-1USAGE:\s0 twinscan2bsml.pl 
        \-\-input_file=/path/to/twinscan.raw.file 
        \-\-output=/path/to/output.bsml
        \-\-project=aa1 
        \-\-fasta_input=/path/to/somefile.fsa 
        \-\-id_repository=/path/to/repository
        \-\-sourcename=sourcename
        \-\-programversion='current'
.SH "OPTIONS"
.IX Header "OPTIONS"
\&\fB\-\-input_file,\-f\fR 
    Input file file from a twinscan run.  \-i, \-\-input_list, will take in a list
    of input files, all of which will be stored in a single output bsml.
.PP
\&\fB\-\-output,\-o\fR 
    Output \s-1BSML\s0 file (will be created, must not exist)
.PP
\&\fB\-\-project,\-p\fR 
    Project \s-1ID\s0.  Used in creating feature ids. 
.PP
\&\fB\-\-fasta_input,\-a\fR
    Needed to create a Seq-data-import element referencing this path.
.PP
\&\fB\-\-id_repository,\-r\fR
    path to \-\-project's id_repository
.PP
\&\fB\-\-programversion,\-v\fR
    Version string to be used as value for the analysis attribute 'programversion'
.PP
\&\fB\-\-sourcename,\-s\fR
    Sourcename string to be used as value for the analysis attribute 'sourcename'
    Due to a silly hack in analysis2bsml.pl, you might need to put /dummy/dir at
    the end of it.
.PP
\&\fB\-\-log,\-l\fR 
    Log file
.PP
\&\fB\-\-debug,\-d\fR 
    Debug level.  Use a large number to turn on verbose debugging. 
.PP
\&\fB\-\-help,\-h\fR 
    This help message
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This script is used to convert the output from a twinscan search into \s-1BSML\s0.
.SH "INPUT"
.IX Header "INPUT"
You define the input file using the \-\-input_file option.  This file does not need any
special file extension.  The regular output of twinscan, less about a dozen comment
lines of header, looks like this:
.PP
eda1.assembly.1.1.0.seq iscan   \s-1CDS\s0 62 293      6764    +       1       gene_id \*(L"eda1.assembly.1.1.0.seq.001\*(R"; transcript_id \*(L"eda1.assembly.1.1.0.seq.001.1\*(R";
eda1.assembly.1.1.0.seq iscan   stop_codon      294     296     .       +       0       gene_id \*(L"eda1.assembly.1.1.0.seq.001\*(R"; transcript_id \*(L"eda1.assembly.1.1.0.seq.001.1\*(R";
eda1.assembly.1.1.0.seq iscan   start_codon     460     462     .       +       0       gene_id \*(L"eda1.assembly.1.1.0.seq.002\*(R"; transcript_id \*(L"eda1.assembly.1.1.0.seq.002.1\*(R";
eda1.assembly.1.1.0.seq iscan   \s-1CDS\s0 460 502     903     +       0       gene_id \*(L"eda1.assembly.1.1.0.seq.002\*(R"; transcript_id \*(L"eda1.assembly.1.1.0.seq.002.1\*(R";
eda1.assembly.1.1.0.seq iscan   \s-1CDS\s0 513 565     427     +       2       gene_id \*(L"eda1.assembly.1.1.0.seq.002\*(R"; transcript_id \*(L"eda1.assembly.1.1.0.seq.002.1\*(R";
eda1.assembly.1.1.0.seq iscan   stop_codon      566     568     .       +       0       gene_id \*(L"eda1.assembly.1.1.0.seq.002\*(R"; transcript_id \*(L"eda1.assembly.1.1.0.seq.002.1\*(R";
eda1.assembly.1.1.0.seq iscan   start_codon     742     744     .       +       0       gene_id \*(L"eda1.assembly.1.1.0.seq.003\*(R"; transcript_id \*(L"eda1.assembly.1.1.0.seq.003.1\*(R";
eda1.assembly.1.1.0.seq iscan   \s-1CDS\s0 742 802     411     +       0       gene_id \*(L"eda1.assembly.1.1.0.seq.003\*(R"; transcript_id \*(L"eda1.assembly.1.1.0.seq.003.1\*(R";
eda1.assembly.1.1.0.seq iscan   \s-1CDS\s0 826 926     2058    +       2       gene_id \*(L"eda1.assembly.1.1.0.seq.003\*(R"; transcript_id \*(L"eda1.assembly.1.1.0.seq.003.1\*(R";
eda1.assembly.1.1.0.seq iscan   stop_codon      927     929     .       +       0       gene_id \*(L"eda1.assembly.1.1.0.seq.003\*(R"; transcript_id \*(L"eda1.assembly.1.1.0.seq.003.1\*(R";
eda1.assembly.1.1.0.seq iscan   stop_codon      1016    1018    .       \-       0       gene_id \*(L"eda1.assembly.1.1.0.seq.004\*(R"; transcript_id \*(L"eda1.assembly.1.1.0.seq.004.1\*(R";
eda1.assembly.1.1.0.seq iscan   \s-1CDS\s0 1019        1146    890     \-       2       gene_id \*(L"eda1.assembly.1.1.0.seq.004\*(R"; transcript_id \*(L"eda1.assembly.1.1.0.seq.004.1\*(R";
.PP
which has the general format of:
.PP
.Vb 1
\&    <seqname> <source> <feature> <start> <end> <score> <strand> <frame> [attributes]
.Ve
.PP
where attributes contains:
    \*(L"gene_id\*(R", referring to the source input sequence followed by a unique gene id.
    \*(L"transcript_id\*(R", referring to the gene_id followed by a transcript id, which will
        always be '.1' for twinscan, until multiple predictions per gene (that is,
        alternative splices) are implemented.
.PP
This script currently assumes that the input \s-1GTF\s0 file only contains the output from
the analysis of a single \s-1FASTA\s0 sequence.
.PP
Also it should be noted that all transcripts will have, at a minimum, 2 rows: a \s-1CDS\s0
and a stop_codon.  If there are at least 2 \s-1CDS\s0 predictions, an additional start_codon
is added to the results.  
.SH "OUTPUT"
.IX Header "OUTPUT"
Base positions from the input file are renumbered so that positions start at zero and
reflect interbase numbering.  Also, the stop coordinates of each terminal \s-1CDS\s0 is
extended 3bp to include the stop codon.
.SH "CONTACT"
.IX Header "CONTACT"
.Vb 2
\&    Jason Inman
\&    jinman@tigr.org
.Ve
