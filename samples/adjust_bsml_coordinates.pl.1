.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ADJUST_BSML_COORDINATES 1"
.TH ADJUST_BSML_COORDINATES 1 "2010-10-22" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
adjust_bsml_coordinates.pl \- adjust the positional coordinates within a BSML file
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\s-1USAGE:\s0  adjust_bsml_coordinates.pl
            \-\-map_file=/path/to/somemapfile.bsml
            \-\-map_dir=/or/path/to/somedir
            \-\-list_file=/path/to/somefile.list
            \-\-input_file=/paht/to/somefile.bsml
            \-\-output_dir=/path/to/somedir
            \-\-removed_log=/path/to/some/removed.log
          [ \-\-filter_ends=1|0
            \-\-debug=4
            \-\-log=/path/to/somefile.log
          ]
.SH "OPTIONS"
.IX Header "OPTIONS"
\&\fB\-\-map_file,\-m\fR 
    Input \s-1BSML\s0 map file.
.PP
\&\fB\-\-map_dir,\-d\fR 
    Directory of input \s-1BSML\s0 map files.
.PP
\&\fB\-\-list_file,\-i\fR 
    Path to a list of analysis \s-1BSML\s0 output files.
.PP
\&\fB\-\-input_file,\-n\fR
    Path to the input file to be adjusted and searched for overlap
.PP
\&\fB\-\-output_list,\-u\fR
    Optional.  If passed, will create an output list with the full paths to each of the 
    \s-1BSML\s0 files created by this script.
.PP
\&\fB\-\-output_dir,\-o\fR 
    Directory where output \s-1BSML\s0 files will be written.
.PP
\&\fB\-\-removed_log,\-r\fR
    The log file where duplicate elements will be printed to after
    removal.
.PP
\&\fB\-\-filter_ends,\-f\fR 
    \s-1NOT\s0 \s-1YET\s0 \s-1IMPLEMENTED\s0
.PP
\&\fB\-\-debug,\-d\fR 
    Debug level.  Use a large number to turn on verbose debugging. 
.PP
\&\fB\-\-log,\-l\fR 
    Log file
.PP
\&\fB\-\-help,\-h\fR 
    This help message
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Because some sequences are too large to be analyzed directly by some analysis tools, 
it is sometimes necessary to first split those sequences into pieces, perform the 
analysis on each fragment, and then stitch them back together. This last step causes 
problems because any coordinates given in the result file will represent the 
coordinates of the query in the fragment, and not be representative of the coordinates 
of the original sequence.
.PP
The purpose of this script is to read through the \s-1BSML\s0 results of such an analysis and 
adjust the coordinates to reflect those in the original input file.  This is done using
a set of \s-1BSML\s0 output files along with a mapping file.  Read the \s-1INPUT\s0 section for more
information.
.PP
Additionally, this script will search neighboring fragments of the input_file fragment
and search for overlapping location specific predictions.  If a prediction is matched
it is removed from the \s-1BSML\s0 file.  Also, if a location is contained completely within another,
the smaller of the locations is removed.
.PP
To use this component, you would most likely have used a splitting component previously
in the pipeline, such as split_fasta, which generates the input maps.
.PP
The list of attributes that are adjusted are defined within the script, and are currently
refstart, refend, refpos, start, startpos, endpos, sitepos.
.SH "INPUT"
.IX Header "INPUT"
Three types of input files are required to for this to work.  The first is a list of the
\&\s-1BSML\s0 result files from an analysis, defined using \-\-list_file.  The list file should
look something like this:
.PP
.Vb 4
\&    /some/path/cpa1.assem.1.0.aat_aa.bsml
\&    /some/path/cpa1.assem.1.1.aat_aa.bsml
\&    /some/path/cpa1.assem.1.10.aat_aa.bsml
\&    /some/path/cpa1.assem.1.11.aat_aa.bsml
.Ve
.PP
In this case, an aat_aa analysis was run on 4 sequences, probably named like cpa1.assem.1.0
.PP
The \s-1BSML\s0 mapping file, passed with the \-\-map_file option, gives information about how the
coordinates in these files relate to the original non-split file, here named cpa1.assem.1
.PP
If mapping information for the files in your list come from multiple \s-1BSML\s0 maps, you can use
the \-\-map_dir option.  This will load all maps in the specified directory whose names end
in '.map.bsml'
.PP
Also note this script handles compressed input.  If the input \s-1BSML\s0 files have been gzipped
and end in either the '.gz' or '.gzip' extension, they will be decompressed, modified and
recompressed on the fly.
.SH "OUTPUT"
.IX Header "OUTPUT"
The output \s-1BSML\s0 files will be written to the directory specified by \-\-output_dir.  You may
specify the output_dir to be the same location as the original files to overwrite them.
.PP
As each \s-1BSML\s0 file is analyzed, a few changes are made to reflect the coordinates back onto
the non-fragmented sequence.  The following elements are searched and the attributes listed
are modified:
.PP
.Vb 5
\&    <Aligned-sequence> - start
\&    <Interval-loc> - startpos, endpos
\&    <Seq-pair-alignment> - refseq, refxref, refstart, refend
\&    <Seq-pair-run> - refpos
\&    <Site-loc> - sitepos
.Ve
.PP
In addition to these, any references to the fragment \s-1ID\s0 are changed back to the original
sequence.  E.g.
.PP
.Vb 1
\&    cpa1.assem.1.0  -->  cpa1.assem.1
.Ve
.PP
Also, an Analysis element is added to reflect that this script modified the file.
.PP
Note that the file names, such as cpa1.assem.1.0.aat_aa.bsml, are not changed, though
they no longer contain information directly concerning the fragment.  This way these
sequences can be loaded as they are \- else we would have to concatenate each of the
fragmented files into one large \s-1BSML\s0 file before loading, which is not desirable.
.PP
\&\s-1NOTE:\s0  The \s-1BSML\s0 output currently has a return character between elements that are
analyzed.  This is an artifact of XML::Twig's printing methods that I have yet to 
resolve.  
.SH "CONTACT"
.IX Header "CONTACT"
.Vb 2
\&    Kevin Galens
\&    kgalens@tigr.org
.Ve
.PP
.Vb 2
\&    Joshua Orvis
\&    jorvis@tigr.org
.Ve
