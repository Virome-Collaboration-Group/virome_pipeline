.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FASTA2BSML 1"
.TH FASTA2BSML 1 "2010-10-22" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
fasta2bsml.pl \- convert fasta files to BSML
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\s-1USAGE:\s0  fasta2bsml.pl 
        \-\-fasta_input=/path/to/fileORdir | \-\-fasta_list=/path/to/file
        \-\-format=multi|single
        \-\-output=/path/to/somefile.fsa   | /path/to/somedir
      [ \-\-class=assembly
        \-\-output_list=/path/to/somefile.list
        \-\-output_subdir_size=20000
        \-\-output_subdir_prefix='somename'
        \-\-debug=debug_level 
        \-\-log=log_file 
      ]
.SH "OPTIONS"
.IX Header "OPTIONS"
\&\fB\-\-class,\-c\fR 
    Sets the class attribute of each Sequence element created.  Default = assembly.
.PP
\&\fB\-\-fasta_input,\-i\fR 
    Input files or folders.  Can be a comma-separated list of mixed input types.
.PP
\&\fB\-\-fasta_list,\-s\fR 
    Text file that is a list of input files and/or folders.
.PP
\&\fB\-\-debug,\-d\fR 
    Debug level.  Use a large number to turn on verbose debugging. 
.PP
\&\fB\-\-format,\-f\fR 
    Format.  'multi' (default) writes all sequences to a multi-entry bsml file, and 'single' writes each sequence in a separate file named like \f(CW$id\fR.bsml
.PP
\&\fB\-\-log,\-l\fR 
    Log file
.PP
\&\fB\-\-output,\-o\fR 
    Output file (if \-\-format=multi) or directory (if \-\-format=single)
.PP
\&\fB\-\-output_list,\-u\fR
    Optional.  If passed, will create a list file containing the path to each of the
    files created.
.PP
\&\fB\-\-output_subdir_size,\-z\fR
    Optional.  Number of files to create within each output subdirectory.
.PP
\&\fB\-\-output_subdir_prefix,\-x\fR
    Optional.  Rather than just plain numberical names (N), output subdirectories will
    be named like \*(L"prefixN\*(R" if you pass a prefix with this.
.PP
\&\fB\-\-help,\-h\fR 
    This help message
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This script is used to convert fasta to \s-1BSML\s0.  The input is meant to be as flexible 
as possible and is described below.  The output can be either a single file with 
multiple <Sequence> entries, or separate files for each entry.
.SH "INPUT"
.IX Header "INPUT"
Input can be either a single file, a directory of files, or a list.  A list is
a text file containing a list of either files or directories, one on each line.
.PP
Any individual fasta file can have a single entry or multiple entries.  This
script will separate them as needed.
.PP
The \-\-fasta_input option is used to pass files or directories.  The following
example passes a single fasta file:
.PP
.Vb 1
\&    fasta2bsml.pl --fasta_input=/foo/bar/dnaA.fna
.Ve
.PP
We can pass multiple files in a comma-separated list (use quotes):
.PP
.Vb 1
\&    fasta2bsml.pl --fasta_input="/foo/bar/dnaA.fna, /foo/bar/tonB.faa"
.Ve
.PP
If /foo/bar had many fasta files in it and we want to process them all, we could 
just do:
.PP
.Vb 1
\&    fasta2bsml.pl --fasta_input=/foo/bar
.Ve
.PP
Also multiple directories are ok:
.PP
.Vb 1
\&    fasta2bsml.pl --fasta_input="/foo/bar, /home/you"
.Ve
.PP
You can even mix directories and files:
.PP
.Vb 1
\&    fasta2bsml.pl --fasta_input="/foo/bar/dnaA.fna, /home/you"
.Ve
.PP
Lists are useful if you have a specific set of files or directories to process.
If we have a file named, for example, '/foo/bar/neatstuff.list', which has contents 
like (the .list suffix is completely optional):
.PP
.Vb 4
\&    /foo/bar/thingy1.fna
\&    /foo/bar/thingy2.faa
\&    ...
\&    /foo/bar/thingy1034.fsa
.Ve
.PP
You can pass this list to the script:
.PP
.Vb 1
\&    fasta2bsml.pl --fasta_list=/foo/bar/neatstuff.list
.Ve
.PP
If one of the lines in the list is a path to a directory rather than a file, each
fasta file in that directory will be processed.  A list can contain paths to both
files and directories such as:
.PP
.Vb 5
\&    /foo/bar/thingy1.bsml
\&    /foo/bar/thingy2.bsml
\&    ...
\&    /foo/bar/thingy1034.bsml
\&    /home/you
.Ve
.PP
Finally, you can be really messy and mix input types and methods to process files,
directories and lists all at the same time:
.PP
.Vb 1
\&    fasta2bsml.pl --fasta_input="/foo/bar/dnaA.bsml, /home/you" --fasta_list=/home/you/some.list
.Ve
.PP
Once everything is evaluated down to the file\-level, all will be skipped that
don't have one of the following suffices: .fsa .faa .fna .fasta
.SH "OUTPUT"
.IX Header "OUTPUT"
The fasta format is limited in its data representation in the header.  Because of this,
this script was written very generically to allow any sort of header.  In each <Sequence>
element created, the attributes generated are length, title, and id.  (other attributes
my be handled by default in BsmlBuilder).  The id is assumed to be the first part of
the fasta header up to the initial whitespace.  So with this header:
.PP
.Vb 1
\&    >gi46446716  putative chromosomal replication initiator protein, dnaA
.Ve
.PP
The 'id' attribute will be set to 'gi46446716'.  The 'title' attribute is set to
the entire value of the fasta header, including the first word that became the id.
.PP
Output is specified using the required \-\-output and optional \-\-format options.  By
default the output will be a single file containing multiple sequences entries.  So:
.PP
.Vb 1
\&    fasta2bsml.pl --fasta_input=/foo/bar --output=/home/you/seqs.bsml
.Ve
.PP
This would read all the fasta files in /foo/bar and write their sequences to the
seqs.bsml file in /home/you in multi-entry format.  If you want each sequence to be
output separately, you need to use the \-\-format=single option:
.PP
.Vb 1
\&    fasta2bsml.pl --fasta_input=/foo/bar --output=/home/you/data --format=single
.Ve
.PP
This would write each sequence to its own .bsml file into the /home/you/data directory.
Each file will be named using the id attribute of each sequence, like \f(CW$id\fR.fsa .
\&\-\-format=multi is the default and does not need to be passed explicitly.  Note that
the only legal characters for the file name are in the set [ a\-z A\-Z 0\-9 \- _ . ].  Any
other characters will be replaced with underscores.
.PP
You can pass a path to the optional \-\-output_list to create a text file containing the full paths
to each of the \s-1BSML\s0 files created by this script.
.PP
Two other optional arguments, \-\-output_subdir_size and \-\-output_subdir_prefix, can be used
on input sets that are too large to write out to one directory.  This depends on the limitations
of your file system, but you usually don't want 100,000 files written in the same directory.
.PP
If you are going to create 95000 sequences, and use the following option:
.PP
.Vb 2
\&    --output=/some/path
\&    --output_subdir_size=30000
.Ve
.PP
The following will be created:
.PP
.Vb 6
\&    directory              file count
\&    ---------------------------------
\&    /some/path/0/          30000
\&    /some/path/1/          30000
\&    /some/path/2/          30000
\&    /some/path/3/           5000
.Ve
.PP
If you choose to create a list file (and you probably want to), it will contain these paths.
.PP
You may not want the subdirectories to simply be numbers, as above, so you can use the
\&\-\-output_subdir_prefix option.  For example:        
.PP
.Vb 3
\&    --output=/some/path
\&    --output_subdir_size=30000
\&    --output_subdir_prefix=bsml
.Ve
.PP
The following will be created:
.PP
.Vb 6
\&    directory              file count
\&    ---------------------------------
\&    /some/path/bsml0/     30000
\&    /some/path/bsml1/     30000
\&    /some/path/bsml2/     30000
\&    /some/path/bsml3/      5000
.Ve
.SH "CONTACT"
.IX Header "CONTACT"
.Vb 2
\&    Joshua Orvis
\&    jorvis@tigr.org
.Ve
